---
title: "Algospot :: DFS"
date: 2020-01-27 12:23:00 -0400
categories: 알고리즘_공부
tags: Algospot
---

# Depth-first Search (그래프의 깊이 우선 탐색) : AOJ 28단원  
## DFS란
현재 정점과 인접한 간선들을 하나씩 검사해 아직 방문하지 않은 정점으로 향하는 간선이 있다면 해당 간선을 따라가는 탐색 방법이다.  
모든 정점이 연결되어 있지 않을 수 있으니, `dfsAll()`을 통해 모든 정점에 대하여 `dfs()`를 실행해줘야 한다.  

## 시간 복잡도
- 인접 리스트
  - `dfs()`가 모든 정점에서 호출되므로 `|V|`번 호출된다.
  - `dfs()`가 모든 정점에서 호출되면, 모든 간선도 한 번(무향 그래프) 혹은 두 번(방향 그래프) 검사된다.
  - 따라서 시간복잡도는 `O(|V|+|E|)`이다.
- 인접 행렬
  - 마찬가지로 `dfs()`는 `|V|`번 호출된다.
  - 각 정점에서 인접한 간선들을 확인하기 위해 `O(|V|)`의 시간이 든다.
  - 따라서 시간복잡도는 `O(|V|^2)`이다.  

## 의존성 그래프 (dependency graph)
각 작업을 정점으로 표현하고, 작업 간의 의존 관계를 간선으로 표현한 방향 그래프이다. 사이클이 없는 방향 그래프 (DAG)이다.  
- 위상 정렬 (topological sort)
  - `dfsAll()`을 수행하며, `dfs()`가 종료할 때마다 현재 정점의 번호를 기록한다.
  - `dfsAll()`이 끝난 뒤 기록된 순서를 뒤집으면 위상 정렬 결과를 얻을 수 있다.  

## 오일러 서킷 (Eulerian circuit)
그래프의 모든 간선을 정확히 한 번씩 지나서 시작점으로 돌아오는 경로를 찾는 문제이다.  
**모든 정점들이 짝수점이며, 간선들이 하나의 컴포넌트에 포함된 그래프에서 항상 오일러 서킷을 찾을 수 있다.**  
- 모든 정점들이 짝수점일 때 오일러 서킷 찾기
  - 경로 상의 정점들 중 지나지 않은 간선과 인접한 정점을 찾는다.
  - 모든 점이 짝수점이므로, 해당 정점에는 짝수개의 지나지 않은 간선이 존재한다.
  - 아직 지나가지 않은 간선들로 이루어진 해당 정점을 시작점과 끝점으로 하는 새로운 경로를 찾은 뒤, 기존의 경로에 합친다.
- 구현
  - 재귀 호출이 끝나고 반환할 때 정점을 경로에 추가한뒤, 마지막에 경로를 뒤집는다.
- 오일러 트레일
  - 그래프의 모든 간선을 포함하고 있지만, 시작점과 끝점이 다른 경우
  - 끝점 -> 시작점인 간선을 추가한 뒤, 오일러 서킷을 찾는 문제로 생각한다.  

## DFS 간선의 분류
- DFS를 통해 얻은 그래프는 첫 정점을 루트로 하는 트리 형태이다. 이를 **깊이 우선 탐색 스패닝 트리** 혹은 **DFS 스패닝 트리(DFS Spanning Tree)**라고 한다.
- 이미 발견한 정점으로 연결되는 간선으로부터 얻는 정보도 많다.
  - 트리 간선(tree edge)
    - 스패닝 트리에 포함된 간선
  - 순방향 간선(forward edge)
    - 스패닝 트리의 선조에서 자손으로 연결되지만 트리 간선이 아닌 간선
  - 역방향 간선(back edge)
    - 스패닝 트리의 자손에서 선조로 연결되는 간선
  - 교차 간선(cross edge)
    - 위 세 가지 분류를 제외한 나머지 간선
- DFS에서 어떤 순서로 정점을 방문하는지에 따라 각 간선의 구분이 달라질 수 있다.
- 무향 그래프에서는 교차 간선이 없다.
  - 증명 : 간선 `(u,v)`가 교차 간선이기 위해서는 정점 v가 먼저 방문된 후 정점 u를 방문하지 않고 종료되어야 한다. 하지만 간선 `(u,v)`를 이용하여 v에서 u를 방문할 수 있기 때문에 불가능하다.  

## 위상 정렬 알고리즘의 정당성 증명
- 위상 정렬 알고리즘에서는 `dfs()`의 종료 역순으로 정점을 배열한다. `dfs(u)`가 `dfs(v)`보다 일찍 종료할 경우 u에서 v로 가는 간선이 없음을 보이면 그 정당성을 보일 수 있다.
- 증명 : 간선 `(u,v)`가 존재한다고 가정한다.
  - 간선 `(u,v)`가 트리 간선인 경우  
    - `dfs(u)`에서 `dfs(v)`를 호출한 것이므로, `dfs(u)`가 먼저 종료될 수 없다.
  - 간선 `(u,v)`가 역방향 간선인 경우
    - 정점 v가 정점 u의 선조이므로, 정점 v에서 u로 가는 경로가 있다. 이 경로에 간선 `(u,v)`를 더하면 사이클이 되므로, 그래프가 DAG라는 가정에 모순이다.
  - 간선 `(u,v)`가 순방향 간선인 경우
    - 정점 u가 정점 v의 선조라는 뜻인데, 이 경우 `dfs(u)`가 먼저 종료될 수 없다.
  - 간선 `(u,v)`가 교차 간선인 경우
    - `dfs(v)`가 종료된 후 정점 u를 방문하였다는 뜻인데, 이는 `dfs(u)`가 먼저 종료된다는 것에 모순이다.
  - 따라서 간선 `(u,v)`는 존재하지 않으며, 위상 정렬 알고리즘의 정당성이 증명되었다.  

## 사이클 존재 여부 확인하기
- 사이클의 존재 여부는 역방향 간선의 존재 여부와 동치이다.  

## 간선을 구분하는 방법
- `dfs(u)` 내에서 간선 `(u,v)`를 검사했을 때, v가 방문된 적 없는 경우 트리 간선이다.
- v가 방문된 적 있는 경우, 추가적인 정보가 필요하다. 탐색 과정에서 각 정점을 몇 번째로 방문했는지를 배열 `discovered[]`에 저장하기로 한다.
  - 간선 `(u,v)`가 순방향 간선이라면, v는 u의 자손이다. 따라서 v는 u보다 늦게 발견된다.
  - 간선 `(u,v)`가 역방햔 간선이려면 v는 u의 선조이다. 따라서 v는 u보다 일찍 발견된다.
  - 간선 `(u,v)`가 교차 간선이려면 `dfs(v)`가 종료한 후 `dfs(u)`가 호출된다. 따라서 v는 u보다 일찍 발견된다.
  - **v가 u보다 일찍 발견된 경우, `dfs(v)`가 종료되었으면 교차 간선이고 그렇지 않으면 역방향 간선이다. 이를 위해 각 정점의 `dfs()`가 종료되었는지를 배열 `finished[]`에 저장한다.**
## 절단점 찾기
- 절단점 : 이 정점과 인접한 간선들을 모두 지우면 해당 컴포넌트가 두 개 이상으로 나누어지는 정점
- 어느 정점 u가 절단점인지 확인하기
  - **무향 그래프에는 교차 간선이 없다는 사실을 이용한다.**
    - 정점 u에 연결된 정점들은 선조 아니면 자손이다.
    - u의 자손들을 루트로 하는 서브트리들이 서로 연결되어 있지 않다. 서브트리 사이에 간선이 있다면 교차 간선일텐데, 무향 그래프에는 교차 간선이 없기 떄문이다.
    - 따라서 u가 절단점이 아니려면, u의 자손들이 u의 선조와 역방향 간선으로 연결되어 있어야 한다. 
      - 각 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 갈 수 있는 정점의 최소 깊이를 반환하는 `dfs2()`를 통해, u의 자손들이 모두 역방향 간선을 통해 u의 선조로 올라갈 수 있는지 확인하면 된다.
    - u가 스패닝 트리의 루트여서 선조가 없는 경우
      - 자손이 없거나 한 개인 경우는 절단점이 아니다.
      - 자손이 두 개 이상이면 절단점이다.
  - **각 정점의 깊이를 비교하는 대신, 발견 순서를 비교한다.**
    - u의 조상은 u보다 먼저 발견된다.
    - DFS 탐색 함수가 각 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 닿는 정점들의 최소 발견 순서를 반환하도록 하면 된다.
- 이중 결합 컴포넌트(biconnected component) : 무향 그래프에서 절단점을 포함하지 않는 서브그래프

    
  