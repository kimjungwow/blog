---
title: "Algospot :: DFS"
date: 2020-01-27 12:23:00 -0400
categories: 알고리즘_공부
tags: Algospot DFS
---

# Depth-first Search (그래프의 깊이 우선 탐색) : AOJ 28단원  
## DFS란
현재 정점과 인접한 간선들을 하나씩 검사해 아직 방문하지 않은 정점으로 향하는 간선이 있다면 해당 간선을 따라가는 탐색 방법이다.  

모든 정점이 연결되어 있지 않을 수 있으니, `dfsAll()`을 통해 모든 정점에 대하여 `dfs()`를 실행해줘야 한다.  

## 시간 복잡도
- 인접 리스트
  - `dfs()`가 모든 정점에서 호출되므로 `|V|`번 호출된다.
  - `dfs()`가 모든 정점에서 호출되면, 모든 간선도 한 번(무향 그래프) 혹은 두 번(방향 그래프) 검사된다.
  - 따라서 시간복잡도는 `O(|V|+|E|)`이다.
- 인접 행렬
  - 마찬가지로 `dfs()`는 `|V|`번 호출된다.
  - 각 정점에서 인접한 간선들을 확인하기 위해 `O(|V|)`의 시간이 든다.
  - 따라서 시간복잡도는 `O(|V|^2)`이다.  

## 의존성 그래프 (dependency graph)
각 작업을 정점으로 표현하고, 작업 간의 의존 관계를 간선으로 표현한 방향 그래프이다. 사이클이 없는 방향 그래프 (DAG)이다.  
- 위상 정렬 (topological sort)
  - `dfsAll()`을 수행하며, `dfs()`가 **종료할 때마다** 현재 정점의 번호를 기록한다.
  - `dfsAll()`이 끝난 뒤 **기록된 순서를 뒤집으면** 위상 정렬 결과를 얻을 수 있다.  

## 오일러 서킷 (Eulerian circuit)
그래프의 모든 간선을 정확히 한 번씩 지나서 시작점으로 돌아오는 경로를 찾는 문제이다.  
**모든 정점들이 짝수점이며, 간선들이 하나의 컴포넌트에 포함된 그래프에서 항상 오일러 서킷을 찾을 수 있다.**  
- 모든 정점들이 짝수점일 때 오일러 서킷 찾기
  - 경로 상의 정점들 중 지나지 않은 간선과 인접한 정점을 찾는다.
  - 모든 점이 짝수점이므로, 해당 정점에는 짝수개의 지나지 않은 간선이 존재한다.
  - 아직 지나가지 않은 간선들로 이루어진 해당 정점을 시작점과 끝점으로 하는 새로운 경로를 찾은 뒤, 기존의 경로에 합친다.
- 구현
  - 재귀 호출이 끝나고 반환할 때 정점을 경로에 추가한뒤, 마지막에 경로를 뒤집는다.
- 오일러 트레일
  - 그래프의 모든 간선을 포함하고 있지만, 시작점과 끝점이 다른 경우
  - 끝점 -> 시작점인 간선을 추가한 뒤, 오일러 서킷을 찾는 문제로 생각한다.  

## DFS 간선의 분류
- DFS를 통해 얻은 그래프는 첫 정점을 루트로 하는 트리 형태이다. 이를 **깊이 우선 탐색 스패닝 트리** 혹은 **DFS 스패닝 트리(DFS Spanning Tree)**라고 한다.
- 이미 발견한 정점으로 연결되는 간선으로부터 얻는 정보도 많다.
  - 트리 간선(tree edge)
    - 스패닝 트리에 포함된 간선
  - 순방향 간선(forward edge)
    - 스패닝 트리의 선조에서 자손으로 연결되지만 트리 간선이 아닌 간선
  - 역방향 간선(back edge)
    - 스패닝 트리의 자손에서 선조로 연결되는 간선
  - 교차 간선(cross edge)
    - 위 세 가지 분류를 제외한 나머지 간선
- DFS에서 어떤 순서로 정점을 방문하는지에 따라 각 간선의 구분이 달라질 수 있다.
- 무향 그래프에서는 교차 간선이 없다.
  - 증명 : 간선 `(u,v)`가 교차 간선이기 위해서는 정점 v가 먼저 방문된 후 정점 u를 방문하지 않고 종료되어야 한다. (그렇지 않으면 트리 간선이다.) 하지만 간선 `(u,v)`를 이용하여 v에서 u를 방문할 수 있기 때문에 불가능하다.  

## 위상 정렬 알고리즘의 정당성 증명
- 위상 정렬 알고리즘에서는 `dfs()`의 종료 역순으로 정점을 배열한다. `dfs(u)`가 `dfs(v)`보다 일찍 종료할 경우 u에서 v로 가는 간선이 없음을 보이면 그 정당성을 보일 수 있다.
- 증명 : 간선 `(u,v)`가 존재한다고 가정한다.
  - 간선 `(u,v)`가 트리 간선인 경우  
    - `dfs(u)`에서 `dfs(v)`를 호출한 것이므로, `dfs(u)`가 먼저 종료될 수 없다.
  - 간선 `(u,v)`가 역방향 간선인 경우
    - 정점 v가 정점 u의 선조이므로, 정점 v에서 u로 가는 경로가 있다. 이 경로에 간선 `(u,v)`를 더하면 사이클이 되므로, 그래프가 DAG라는 가정에 모순이다.
  - 간선 `(u,v)`가 순방향 간선인 경우
    - 정점 u가 정점 v의 선조라는 뜻인데, 이 경우 `dfs(u)`가 먼저 종료될 수 없다.
  - 간선 `(u,v)`가 교차 간선인 경우
    - `dfs(v)`가 종료된 후 정점 u를 방문하였다는 뜻인데, 이는 `dfs(u)`가 먼저 종료된다는 것에 모순이다.
  - 따라서 간선 `(u,v)`는 존재하지 않으며, 위상 정렬 알고리즘의 정당성이 증명되었다.  

## 사이클 존재 여부 확인하기
- 사이클의 존재 여부는 역방향 간선의 존재 여부와 동치이다.  

## 간선을 구분하는 방법
- `dfs(u)` 내에서 간선 `(u,v)`를 검사했을 때, v가 방문된 적 없는 경우 트리 간선이다.
- v가 방문된 적 있는 경우, 추가적인 정보가 필요하다. 탐색 과정에서 각 정점을 몇 번째로 방문했는지를 배열 `discovered[]`에 저장하기로 한다.
  - 간선 `(u,v)`가 순방향 간선이라면, v는 u의 자손이다. 따라서 v는 u보다 늦게 발견된다.
  - 간선 `(u,v)`가 역방햔 간선이려면 v는 u의 선조이다. 따라서 v는 u보다 일찍 발견된다.
  - 간선 `(u,v)`가 교차 간선이려면 `dfs(v)`가 종료한 후 `dfs(u)`가 호출된다. 따라서 v는 u보다 일찍 발견된다.
  - **v가 u보다 일찍 발견된 경우, `dfs(v)`가 종료되었으면 교차 간선이고 그렇지 않으면 역방향 간선이다. 이를 위해 각 정점의 `dfs()`가 종료되었는지를 배열 `finished[]`에 저장한다.**  

## 절단점 찾기
- 절단점 : 이 정점과 인접한 간선들을 모두 지우면 해당 컴포넌트가 두 개 이상으로 나누어지는 정점
- 어느 정점 u가 절단점인지 확인하기
  - **무향 그래프에는 교차 간선이 없다는 사실을 이용한다.**
    - 정점 u에 연결된 정점들은 선조 아니면 자손이다.
    - u의 자손들을 루트로 하는 서브트리들이 서로 연결되어 있지 않다. 서브트리 사이에 간선이 있다면 교차 간선일텐데, 무향 그래프에는 교차 간선이 없기 떄문이다.
    - 따라서 u가 절단점이 아니려면, u의 자손들이 u의 선조와 역방향 간선으로 연결되어 있어야 한다. 
      - 각 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 갈 수 있는 정점의 최소 깊이를 반환하는 `dfs2()`를 통해, u의 자손들이 모두 역방향 간선을 통해 u의 선조로 올라갈 수 있는지 확인하면 된다.
    - u가 스패닝 트리의 루트여서 선조가 없는 경우
      - 자손이 없거나 한 개인 경우는 절단점이 아니다.
      - 자손이 두 개 이상이면 절단점이다.
  - **각 정점의 깊이를 비교하는 대신, 발견 순서를 비교한다.**
    - u의 조상은 u보다 먼저 발견된다.
    - DFS 탐색 함수가 각 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 닿는 정점들의 최소 발견 순서를 반환하도록 하면 된다.
- 이중 결합 컴포넌트(biconnected component) : 무향 그래프에서 절단점을 포함하지 않는 서브그래프  

## 다리 찾기
- 다리 : 어떤 간선을 삭제햇을 때 이 간선을 포함하던 컴포넌트가 두 개의 컴포넌트로 쪼개질 경우 이 간선을 다리(bridge)라고 한다.
- 다리는 항상 트리 간선이다. 어떤 간선 `(u,v)`가 순방향 간선 혹은 역방향 간선이면, u와 v를 잇는 또 다른 경로가 있다는 뜻이므로, `(u,v)`는 다리가 될 수 없기 때문이다.
- DFS 스패닝 트리 상에서 u가 v의 부모일 때, 트리 간선 `(u,v)`가 다리가 되려면?
  - 역방향 간선 중 자신의 부모로 가는 간선을 무시하도록 한 뒤, v와 그 자손들에서 역방향 간선으로 닿을 수 있는 정점의 최소 발견 순서가 u 후라면 `(u,v)`가 다리이다.  

## 강결합 컴포넌트 분리
- 강결합 컴포넌트(strongly connected components, SCC) : 방향 그래프 상에서 두 정점 u와 v에 대해 양 방향으로 가는 경로가 모두 있을 때 두 정점은 같은 SCC에 속한다.
- 각 SCC 사이를 연결하는 간선들을 모으면 SCC들을 정점으로 하는 DAG를 만들 수 있다. 이 과정을 압축(condensation)이라고 한다.
- 한 사이클에 포함된 정점들은 같은 SCC에 있다. 반대로 한 SCC에 속한 두 정점 사이를 잇는 양방향 경로를 합치면 두 정점을 포함하는 사이클이 된다.  

## 타잔 알고리즘
- 한 번의 깊이 우선 탐색으로 각 정점을 SCC별로 분리한다.
  - 간선을 타고 내려가는 시점이 아니라, 반환되는 시점에 간선을 자른다.
  - 트리 간선 `(u,v)`를 자른다는 것은 v에서 u로 갈 수 있는 경로가 없다는 뜻이다.
    - 역방향 간선 : 절단점 판단 알고리즘처럼, v를 루트로 하는 서브트리를 탐색하며 만나는 역방향 간선들이 갈 수 있는 가장 높은 위치를 찾는다. 그 높이가 u보다 높으면 `(u,v)`를 자르면 안된다.
    - 교차 간선 : 교차 간선으로 연결된 이미 탐색된 정점이 별도의 SCC로 묶여 있다는 것은, 이미 탐색된 그 정점을 포함하는 서브트리가 간선 하나를 제거하여 분리되었다는 뜻이다. 즉, 교차 간선으로 연결된 정점이 이미 SCC로 묶여 있다면, 교차 간선을 통해 선조로 올라갈 수 없으므로, v에서 u로 갈 수 있는 경로가 없다. 하지만 v보다 먼저 발견되었으면서 아직 SCC로 묶이지 않은 정점과 교차 간선으로 연결되었다면 v에서 u로 가는 경로가 있다는 것이므로, `(u,v)`를 자르면 안된다.
- 현재 정점을 루트로 하는 서브트리를 한 SCC로 묶기로 결정하면 스택을 이용한다.
  - 아직 발견되지 않은 정점들, 혹은 이미 발견되었지만 현재 정점의 선조보다 발견 순서가 늦은 정점들만 현재 정점과 연결된 경우, 현재 정점을 루트로 하는 서브트리를 하나의 SCC로 묶는다.