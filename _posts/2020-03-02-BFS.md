---
title: "Algospot :: BFS"
date: 2020-03-02 19:23:00 +0900
categories: 알고리즘_공부
tags: Algospot BFS
---

# Breadth-first Search (그래프의 너비 우선 탐색) : AOJ 29단원  
## BFS란
**시작점에서 가까운 정점부터 순서대로 방문하는 탐색 알고리즘이다.**  

BFS는각 정점을 방문할 때마다 모든 인접 정점들을 검사한다. 처음 발견한 정점은 방문할 예정인 정점이라고 기록한 뒤, 별도의 위치에 저장한다. 인접한 정점을 모두 검사하면, 지금까지 저장한 목록에서 다음 정점들을 꺼내서 검사한다. → **큐를 사용**  

BFS의 방문 순서는 정점의 목록에서 어떤 정점을 먼저 꺼내는지에 의해 결정된다.

모든 정점들은 다음의 세 상태를 순서대로 거친다.
- 아직 발견되지 않은 상태
- 발견되었지만 아직 방문되지 않은 상태 (큐에 저장됨)
- 방문된 상태

DFS처럼 BFS에서 새 정점을 발견하는 데 사용된 간선들만을 모은 트리를 너비 우선 탐색 스패닝 트리 (BFS Spanning Tree)라고 한다.

## BFS의 시간복잡도
모든 정점을 방문하고, 각 정점에 인접한 모든 간선을 확인한다. 따라서 인접 리스트로 구현한 경우는 `O(|V|+|E|)`이고, 인접 행렬로 구현한 경우는 `O(|V|^2)`이다.  

## BFS와 최단 거리
BFS 과정에서 간선 `(u,v)`를 통해 정점 v를 처음 발견해 큐에 넣었다면, 시작점으로부터 v까지의 최단 거리 `distance[v]`는 `distance[u]+1`과 같다.

- 증명
  - 시작점부터 u까지의 최단 경로 맨 뒤에 간선 `(u,v)`를 붙이면 길이 `distance[u]+1`인 경로를 얻을 수 있기 때문에, `distance[v]<=distance[u]+1`이다.
  - `distance[v]<distance[u]+1`이라 가정하자. 이 경로 상에서 v 바로 이전의 정점은 시작점으로부터의 거리가 `distance[u]`보다 작아야 한다. 그러면 이 정점은 u보다 먼저 방문되었어야 하고, 따라서 간선 `(u,v)`를 통해 v를 처음 발견했다는 가정과 모순된다. 따라서 `distance[v]>=distance[u]+1`이다.
  - 즉 `distance[v]==distance[u]+1`이다.

위 속성의 중요한 의미는 시작점으로부터 다른 모든 정점까지의 최단 경로를 BFS 스패닝 트리 위에서 찾을 수 있다는 것이다. 

- 구현
  - 시작으로부터 각 점까지의 최단 경로에서, 각 점의 parent를 저장한다.

## 최단 경로 전략
BFS이 방문하는 정점의 개수에 영향을 주는 것
- 시작 정점에서 목표 정점까지의 거리 d
- 탐색의 분기 수(branching factor) b
- 시작 정점부터 거리가 i인 정점은 대략 `b^i`개 있다.

BFS외에도 최단 경로를 구하는 방법이 있다.
- 예 : 15-퍼즐
  - 4X4 퍼즐에 1~15까지의 칸들이 있으며, 상하좌우로 움직여서 순서대로 놓는 게임이다.
  - BFS로 한다면, 상하좌우로 한 번 움직여서 같아질 수 있는 상태들을 간선으로 연결한다.
  - 낙천적으로 `b=2, d=20`으로 해도 1백만 개 이상의 상태를 방문해야 한다.

## 양방향 탐색 (bidirectional search)
`b=3`일 때 `d=20`이라면, BFS로는 `3^20`개의 정점을 방문해야 한다. 하지만, 시작 정점과 목표 정점에서 각각 출발하여 가장 먼저 같은 정점에 도착할 때, 양쪽 경로를 합쳐서 시작 정점~목표 정점의 경로를 구할 수 있다. 이를 양방향 탐색이라 하며, 이 경우 `2*3^10`개의 정점을 방문하면 된다.  
즉 시간 복잡도, 공간 복잡도가 ![ㅇ](https://latex.codecogs.com/gif.latex?O(b^{d/2}))이다.  

하지만 역방향 간선이 많아서 역방향 탐색의 분기 수가 지나치게 큰 경우에는 사용하기 좋지 않다.


## 점점 깊어지는 탐색(Iteratively Deepening Search, IDS)
양방향 탐색으로도 메모리가 초과될 정도로 d가 큰 경우, 정점을 발견하는 즉시 방문하는 DFS를 이용한다면? 큐가 너무 많은 메모리를 차지하지도 않고, 방문 여부를 저장하지 않으면 사용 메모리를 더욱 줄일 수 있다. 하지만 같은 정점을 여러번 방문하며 사이클에 빠질 수도 있고, 발견한 경로가 최단 경로인지도 모른다.

IDS는 임의의 깊이 제한 l을 정한 후 이보다 짧은 경로가 존재하는지를 DFS로 확인한다. 발견하지 못하면 l을 늘리며 다시 확인한다.  
**전역 변수** `best`를 `l+1`로 설정하고, 탐색 중 경로의 길이가 best이상이 되면 즉각 종료하여 시간 낭비를 막는다. `best`보다 짧은 경로를 발견하면 그 경로의 길이를 `best`에 넣고, `best`가 `l` 이하가 되면 탐색을 종료한다.  

### 추가적인 최적화 
휴리스틱을 이용한 가지치기
- 예 : 15-퍼즐에서 현재 위치와 목표 위치 사이의 맨해튼 거리(x좌표의 차+y좌표의 차)를 휴리스틱으로 정해, 탐색 중인 경로의 길이가 휴리스틱보다 커지면 탐색 종료

### 효율성 평가
깊이 제한을 늘려가면서 DFS를 반복하면 한 정점을 두 번 이상 반복하게 된다. 최단거리가 d이고 탐색의 분기수가 b일 때, 최단 거리가 2인 상태들은 d-1번 반복된다. 총 `(d+1)Xb^0 + dXb^1 + ... + 1Xb^d=O(b^d)`으로, 이는 BFS와 같다. 하지만 BFS에서는 각 상태를 방문했는지 여부를 기록해야 한다. 또한 IDS에서는 여러 가지치기 기법을 이용하기 용이하며, 큐를 사용하지 않기 때문에 스택만 메모리를 `O(d)` 사용한다.

## 탐색 방법 선택하기

1. 상태 공간에서의 최단 경로를 찾는 경우, 직관적이고 구현하기 쉬운 **BFS**를 우선 고려한다. 이 때, 탐색의 깊이 한계가 정해져 있지 않거나 너무 깊어서 메모리 사용량이 너무 크지 않은지 확인해야 한다.
1. 상태 공간에서의 최단 경로를 찾는데, 탐색의 최대 깊이가 정해져 있고 BFS를 하기에는 메모리와 시간이 부족할 경우 **양방향 탐색**을 고려한다. 이 때, 목표 상태에서 역방향으로 움직이기 쉬어야 한다.
1. 두 탐색이 모두 너무 메모리를 많이 사용하거나 느리면 최적화 할 거리가 많은 **IDS**를 사용한다.

## 상태 객체의 구현
효율적이고 메모리를 덜 사용하도록 상태 객체를 구현해야 한다.