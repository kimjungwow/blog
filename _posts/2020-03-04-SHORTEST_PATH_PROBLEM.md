---
title: "Algospot :: Shortest_Path_Problem"
date: 2020-03-04 19:23:00 +0900
categories: 알고리즘_공부
tags: Algospot Shortest_Path_Problem
---

# Shortest Path Problem (최단 경로 알고리즘) : AOJ 30단원  
## 최단 경로 알고리즘
그래프에 가중치가 없는 경우 : BFS 이용  

30단원에서는 그래프에 가중치가 있는 경우를 다룬다.  

### 음수 간선의 중요성
음수 간선을 지나면 전체 경로의 길이가 짧아진다. 특히, 가중치의 합이 음수인 사이클(음수 사이클)이 등장할 수 있기 때문이다. 음수 사이클이 존재하면 경로의 길이는 음의 무한대까지 발산할 수 있으므로, 최단 경로 문제는 제대로 정의되지 않는다. 이 경우 어떤 알고리즘으로도 최단 경로를 정확하게 찾을 수 없다.

### 단일 시작점과 모든 쌍 알고리즘
- 단일 시작점 알고리즘
  - 하나의 시작점에서 다른 모든 정점까지 가는 최단 거리를 구함
- 모든 쌍 알고리즘
  - 모든 정점의 쌍에 대해 최단 거리 계산
  - 수행 결과는 VXV 크기의 배열
  - 예 : 플로이드의 최단 경로 알고리즘

### 방향 그래프와 무방향 그래프
30단원에서 다루는 알고리즘은 모두 방향 그래프를 기준으로 동작한다. 따라서 무방향 그래프는 각각의 양방향 간선을 두 개의 일방 통행 간선으로 쪼개서 방향 그래프로 만들어야만 한다. 하지만 음수 간선이 있는 경우, 음수 간선을 쪼개면 음수 사이클이 생긴다. 따라서 음수 간선이 있는 무방향 그래프에 대해서는 최단 경로 문제를 풀 수 없다.

### 간선 가중치의 표기
간선 `(u,v)`의 가중치를 `w(u,v)`로 쓴다.

## 다익스트라의 최단 경로 알고리즘
다익스트라(Dijkstra) 알고리즘은 단일 시작점 최단 경로 알고리즘이다. BFS에서는 큐를 사용하지만, 다익스트라 알고리즘은 우선순위 큐를 사용한다. 우선순위 큐에는 정점의 번호와 지금까지 찾아낸 해당 정점까지의 최단 거리를 넣는다.  

**각 정점까지의 최단 경로가 갱신될 수 있다.** 예를 들어 정점 `c`까지의 최단 거리가 12인줄 알았다가, 9인 경로를 발견했다고 하자. 이 때 우선순위 큐에는 `(12,c)`를 **그대로 두고,** `(9,c)`를 넣는다. `dist[c]=9`를 설정한 뒤, 나중에 우선순위 큐에서 `(12,c)`가 나오면 `dist[c]<12`이므로 무시하면 된다.  

`STL`의 `priority_queue`를 사용한다면, `pair<int,int>`는 앞의 수를 먼저 비교하므로 `(-최단 경로의 길이, 정점 번호)`꼴로 저장한다. `prioirty_queue`는 prority가 큰 수가 top이지만, 나는 최단 경로의 길이가 짧은 것을 top으로 생각하고 싶기 때문에 **최단 경로의 길이에 -1을 곱해서 넣는다.**

`priority_queue`에 `(0,시작 정점)`을 넣으며 시작한다. 다익스트라 알고리즘에서 선택한 간선을 모으면 BFS 스패닝트리와 같은 트리 형태가 된다. 이 트리의 루트에서 각 정점까지로 가는 경로가 원래 그래프에서의 최단 경로이다.

### 정당성 증명
귀류법을 위해 다익스트라 알고리즘이 최단 거리를 제대로 계산하지 못하는 정점 u가 있다고 가정하자. 이런 정점이 두 개 이상이면 그중 첫 번째로 방문하는 정점을 선택한다.  

시작점에 대해서는 항상 최단 경로가 0임을 알기 때문에, u는 시작점이 아니다. 그러면 다익스트라 알고리즘에서 u를 방문하는 순간, u 이전에 방문한 정점들과 아직 방문하지 않은 정점들로 나눌 수 있다. 이때 u에 대한 최단 거리를 잘못 계산했다는 것은 다익스트라 알고리즘에서 만든 스패닝 트리에서의 경로보다 더 짧은 경로가 존재한다는 것이다.  

시작점으로부터 정점 u까지의 최단 경로를 반대로 따라가다보면, 이미 방문한 정점 p가 나온다. 정점 p와 연결되었고 위 경로에 있지만 아직 방문하지 않은 정점을 정점 q라고 하자. 정점 q까지의 최단거리는 `dist[p]+w(p,q)`이다. 그런데 정점 p가 이미 방문된 상태이므로 정점 q는 이미 우선순위 큐에 들어가 있다. 하지만 정점 u가 정점 q보다 먼저 우선순위 큐에서 꺼내졌으므로 `dist[u]<=dist[q]`이다. 하지만 이는 정점 u로 가는 최단 경로가 정점 q를 지난다는 사실에 모순이다.  

이와 같이 스패닝 트리 위의 경로보다 짧은 경로는 존재할 수 없으므로, 다익스트라 알고리즘이 찾아내는 경로가 최단 경로이다. 하지만 다익스트라 알고리즘은 **음수 간선이 없다고 가정한다.** 

### 다익스트라 알고리즘의 시간 복잡도

- 각 정점마다 인접한 간선들을 모두 검사하는 작업
  - 각 정점은 한 번씩만 방문되고, 따라서 모든 간선은 한 번씩 검사됨
  - `O(|E|)`
- 우선순위 큐에 원소를 넣고 삭제하는 작업
  - BFS에서는 모든 정점이 큐에 한 번씩만 들어가기 때문에 큐의 최대 크기는 `O(|V|)`
  - 하지만 `dist[]`가 갱신될 때마다 원소를 우선순위 큐에 넣는다. 간선마다 최대 한 번 큐에 원소를 추가하므로, 큐의 최대 크기는 `O(|E|)`
  - 우선순위 큐에 원소를 추가하거나 삭제하는데는 `O(lg|E|)`
  - 따라서 전체 시간복잗보는 `O(|E|lg|E|)`
- 두 작업을 합치면 `O(|E|+|E|lg|E|)=O(|E|lg|E|)`인데, 대개의 경우 `|E|`는 `|V|^2`보다 작으므로, `O(|E|lg|E|)=O(|E|lg|V|*2)=O(|E|lg|V|)`이다.

### 최단 경로 찾기

다익스트라 알고리즘을 통해 얻은 스패닝 트리를 거슬러 올라가는 경로가 최단 경로이다.

### O(|V|lg|V|)에 다익스트라 구현하기
중복 원소를 우선순위 큐에 넣지 않으면 `O(|V|lg|V|)`로 짤 수 있지만, 이러려면 피보나치 힙이나 이진 검색 트리를 이용해 우선순위 큐를 작성해야 한다. 이는 시간 복잡도는 줄여주지만 복잡하며, 더 느릴 수도 있다.

### 우선순위 큐를 사용하지 않는 다익스트라 알고리즘의 구현
정점의 수가 적거나 간선의 수가 매우 많은 경우에는 우선순위 큐를 사용하지 않을 때 더 빠를 수 있다. 우선순위 큐 대신 반복문을 통해 매번 방문하지 않은 정점 중 `dist[]` 값이 가장 작은 정점을 찾는다. 이 경우 시간복잡도는 `O(|V|^2+|E|)`이다.