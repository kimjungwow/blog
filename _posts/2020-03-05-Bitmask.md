---
title: "Algospot :: Bitmask"
date: 2020-03-05 10:48:00 +0900
categories: 알고리즘_공부
tags: Algospot Bitmask
---

# Bitmask (비트마스크) : AOJ 16단원  
## Bitmask란
현대의 모든 CPU는 이진수를 이용해 모든 자료를 표현한다. 따라서 이진법 관련 연산들을 아주 빨리 할 수 있다. 이와 같은 특성을 이용해 정수의 이진수 표현을 자료 구조로 쓰는 기법을 비트마스크(bitmask)라고 한다. (엄밀히 말하면 비트마스크는 자료 구조가 아니다.)

### Bitmask의 장점
- 더 빠른 수행 시간 : 대부분 `O(1)`
- 더 간결한 코드 : 짧은 코드 작성 가능
- 더 작은 메모리 사용량 : 더 많은 데이터를 미리 계산해서 저장해 둘 수 있고, 캐시 효율이 좋아짐
- 연관 배열 (예: map)을 배열로 대체 : 느린 `map<vector<bool, int>>` 대신 배열 `int []` 사용 

### 용어 정의
- 이진수의 한 자리를 비트라고 하며, 비트는 0 혹은 1의 값을 자길 수 있다.
- 예를 들어, 부호 없는 8비트 정수는 `0000 0000` 부터 `1111 1111`까지 표현가능하므로 0부터 255까지 표현 가능하다.
- `2^(N-1)`에 해당하는 비트를 최상위 비트 (most significant bit), `2^0`을 나타내는 비트를 최하위 비트(least significant bit)라고 부른다.
- 어떤 정수를 이진수로 나타낼 때 어떤 비트의 위치가 1이라면 해당 비트가 **켜져 있다**라고 말하고, 0이면 **꺼져 있다** 라고 말한다.

### 비트 연산자
- 비트 연산자는 정수 변수를 비트별로 조작할 수 있게 해준다.
- AND 연산
- OR 연산
- XOR 연산 : 하나는 켜져 있고 하나는 꺼져 있을 경우 결과의 비트를 켠다. `a^b` 꼴로 사용한다.
- NOT 연산
- SHIFT 연산

### 유의할 점들
- 연산자 간 우선순위
  - C++이나 자바에서 `&, |, ^`등의 비트 연산자의 우선순위는 `==, !=` 등의 비교 연산자보다 낮다. 따라서 비트마스크를 사용하는 식에는 가능한 한 괄호를 자세하게 추가하는 습관을 들여야 한다.
- 64비트 정수를 비트마스크로 사용할 때 발생하는 오버플로우
  - 예 : `unsigned long long a, int b`에 대해 `return (a & (1 << b)) > 0`
  - C++에서 1은 부호있는 32비트 상수로 취급되기 때문에, b가 32 이상이면 오버플로우가 발생한다. 1 뒤에 이 상수가 부호 없는 64비트 정수임을 알려주는 `ull`을 붙여주어야 한다.
- 부호 있는 정수형의 사용
  - 부호 있는 정수형에서 최상위 비트가 켜진 숫자는 음수를 표현한다. 이에 따라 음수를 오른쪽으로 시프트하면 왼쪽 끝 비트들이 0이 아니라 1로 채워진다. 따라서 변수의 모든 비트를 쓰고 싶으면 부호 없는 정수를 써야 한다.
- N비트 정수를 N비트 이상 왼쪽으로 시프트하는 경우, 예상과 다른 결과가 나올 수 있다.

## 비트마스크를 이용한 집합의 구현
원소 i가 집합에 속해 있는지 여부를 `2^i`를 나타내는 비트가 켜져있는지 여부로 판단한다.
- 피자집 예제
  - 20가지 토핑이 있다면, `bool [20]` 대신 0~19번째 비트를 통해 표현할 수 있다.
  - 상수 0이 공집합을 나타내고, 마지막 20개의 비트가 모두 켜진 `(1<<20)-1`가 꽉 찬 집합을 나타낸다.
  - `toppings |= (1<<p)`를 통해 원소를 추가할 수 있다.
  - `if (toppings & (1 << p))`를 통해 원소의 포함 여부를 확인할 수 있다. 하지만 `if (toppings & (1 << p)==1)`은 올바른 코드가 아니다. p의 위치에 따라 `0x10000` 처럼 1이 아닌 수가 나오기 때문이다.
  - `toppings &= ~(1<<p)`를 통해 원소를 뺄 수 있다. `~(1<<p)`는 해당 비트만 꺼지고 나머지는 다 켜진 숫자이다. `toppings -=(1<<p)`는 p번째 토핑이 포함된 경우에만 올바르게 동작하므로 옳지 않다.
  - 해당 비트가 켜져 있으면 끄고, 꺼져 있으면 키는 것을 **토글(toggle)**이라 한다. `toppings ^= (1<<p)`를 통해 토글할 수 있다.
  - 두 집합에 대해 연산하기
    - `a | b` : a와 b의 합집합
    - `a & b` : a와 b의 교집합
    - `a & ~b` : a에서 b를 뺀 차집합
    - `a ^ b` : a와 b중 하나에만 포함된 원소들의 집합
  - 집합의 크기를 구하려면 각 비트를 순회하면서 켜져 있는 비트의 수를 직접 세야 한다. 직접 구현해도 되지만, 내장 명령어를 이용해도 된다. `gcc/g++`에서는 `__builtin_popcount(toppings)`를, `Visual C++`에서는 `__popcnt(toppings)`를 사용하면 된다. 이 때 `toppings`는 32비트 부호 없는 정수이다.
  - **집합에 포함된 가장 작은 원소를 찾으려면, 정수의 이진수 표현에서 끝에 붙어있는 0의 개수를 세면 된다.** 32비트 부호 없는 정수 `toppings`에 대하여, `gcc/g++`에서는 `__builtin_ctz(toppings)`를, `Visual C++`에서는 `_BitScanForward(&index, toppings)`를 사용하면 된다. 이 때 `__builtin_ctz()`는 입력으로 0이 주어졌을 때 결과가 정의되어 있지 않으니 유의해야 한다. 
  - 최하위 비트의 번호 대신 해당 비트를 직접 구할 수 있다. 40이 주어지면 3이 아닌 `2^3`을 구하는 것이다. 직접 구현하려면 `toppings & -toppings`를 사용하면 된다. 음수 `-toppings`를 표현하기 위해 `toppings`에 비트별 NOT 연산을 적용하고 1을 더하는 2의 보수를 사용한다는 점을 착안한 것이다. `toppings`의 마지막 i+1자리는 1뒤에 i개의 0이 있는 형태인데, NOT 연산을 적용하면 마지막 i+1 자리는 0 뒤에 i개의 1이 있는 형태가 된다. 여기에 1을 더하면 다시 1과 i개의 0이 있는 형태가 된다. `2^i`보다 상위 비트들에는 NOT연산이 적용된 상태이므로 두 수를 AND하면 항상 최하위 비트만을 얻을 수 있다.
  - 최소 원소가 무엇인지에 상관 없이 최소 원소를 지우려면, `toppings &= (toppings-1)`을 사용하면 된다. **1을 뺀 값과 AND 연산했을때 0이 되는지 확인함으로써 2의 거듭제곱인지도 확인할 수 있다.**
  - **모든 부분 집합을 순회해야 할 때도 있다.** `pizza`가 `[페퍼로니, 소시지, 양파]`일 때, 
  
    ```for(int subset=pizza; subset; subset=((subset-1) & pizza)) { subset은 pizza의 부분집합 }```
  
    를 이용하면 된다. for문은 `subset=0`인 시점에 종료하므로 공집합은 방문하지 않는다.

## 비트마스크의 응용 예제

### 지수 시간 동적 계획법
9단원에서 배열 입력을 갖는 함수를 메모이제이션 하는 방법을 공부했다. 이 때 배열 대신 정수로 집합을 표현하면 곧장 배열의 인덱스로 쓸 수 있어서 구현이 간단해진다.

### 에라토스테네스의 체
에라토스테네스의 체는 굉장히 빠르게 동작해서 수행 범위를 늘리면 수행 시간보다는 메모리가 부담된다. 범위 내의 각 정수가 지워졌는지 여부를 저장해야 하는데, 이 떄 불린 값 대신 비트마스크를 사용하면 된다.  

`MAX_N`개의 원소를 갖는 불린 값 배열을 `unsigned char sieve[(MAX_N + 7) / 8]`로 대체할 수 있다. 이 배열은 `int(MAX_N/8 + 1)`바이트만을 써서 `MAX_N`개의 원소를 갖는 불린 값 배열을 구현한다. 이때 k번째 원소가 참인지 알려면 `k/8`번째 원소의 `k%8`번째 비트가 켜져있는지 확인하면 된다. `k%8=k&7`을 이용하면 더욱 빠르다.

또한 2~N까지를 `int i`로 순환하며 소수인지 판단한 후, **소수라면 `i*i`부터 i씩 더해가며 소수가 아니라고 표시해준다. `i`보다 크고 `i*i`보다 작은 i의 배수들은 이미 소수가 아니라고 표시되었음에 주목하자.**

### 15퍼즐 상태 표현하기
`0~15` 16개의 숫자는 각각 4비트로 표현 가능하므로, 전체를 `16X4=64`인 64비트 정수로 15퍼즐의 상태를 표현할 수 있다.

### O(1) 우선순위 큐
큐에 넣는 원소의 우선순위가 1이상 140이하의 정수라면, 각 우선순위를 갖는 원소들을 담는 140개의 큐를 만들고, 각 큐에 원소가 있는지 여부를 비트마스크로 표현한다. 140개의 불린 값을 64비트 정수 3개로 표현하고, 첫 번째 비트를 찾는 연산을 통해 가장 우선순위가 높은 원소를 찾을 수 있다.

### 극대 안정 집합
N개의 화학 물질 중 같이 두었을 때 서로 반응해 폭발하는 물질들이 있다. 물질을 하나라도 추가하면 폭발이 일어나는 집합들을 극대 안정 집합이라 할때, 극대 안정 집합이 몇 개인지 구해야 한다. 각 물질마다 자신과 만나면 폭발하는 물질들의 비트를 1로 설정하여 `explodes[]`에 저장한 뒤, `if((set & (1<<i)) && (set & explodes[i]))`를 통해 안정 집합인지 확인할 수 있다. 또한 안정 집합에 없는 원소들에 대하여 `if((set & (1<<add)) && (set & explodes[add]))`를 모두 확인하여 극대 안정 집합인지 확인할 수 있다.