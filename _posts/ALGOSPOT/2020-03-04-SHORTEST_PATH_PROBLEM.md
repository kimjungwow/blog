---
title: "Algospot :: Shortest_Path_Problem"
date: 2020-03-04 19:23:00 +0900
categories: 알고리즘_공부
tags: Algospot Shortest_Path_Problem
---

# Shortest Path Problem (최단 경로 알고리즘) : AOJ 30단원    

## 최단 경로 알고리즘  

그래프에 가중치가 없는 경우 : BFS 이용  

30단원에서는 그래프에 가중치가 있는 경우를 다룬다.  

### 음수 간선의 중요성  

음수 간선을 지나면 전체 경로의 길이가 짧아진다. 특히, 가중치의 합이 음수인 사이클(음수 사이클)이 등장할 수 있기 때문이다. 음수 사이클이 존재하면 경로의 길이는 음의 무한대까지 발산할 수 있으므로, 최단 경로 문제는 제대로 정의되지 않는다. 이 경우 어떤 알고리즘으로도 최단 경로를 정확하게 찾을 수 없다.

### 단일 시작점과 모든 쌍 알고리즘  

- 단일 시작점 알고리즘
  - 하나의 시작점에서 다른 모든 정점까지 가는 최단 거리를 구함
- 모든 쌍 알고리즘
  - 모든 정점의 쌍에 대해 최단 거리 계산
  - 수행 결과는 VXV 크기의 배열
  - 예 : 플로이드의 최단 경로 알고리즘

### 방향 그래프와 무방향 그래프  

30단원에서 다루는 알고리즘은 모두 방향 그래프를 기준으로 동작한다. 따라서 무방향 그래프는 각각의 양방향 간선을 두 개의 일방 통행 간선으로 쪼개서 방향 그래프로 만들어야만 한다. 하지만 음수 간선이 있는 경우, 음수 간선을 쪼개면 음수 사이클이 생긴다. 따라서 음수 간선이 있는 무방향 그래프에 대해서는 최단 경로 문제를 풀 수 없다.

### 간선 가중치의 표기  

간선 `(u,v)`의 가중치를 `w(u,v)`로 쓴다.

## 다익스트라의 최단 경로 알고리즘  

다익스트라(Dijkstra) 알고리즘은 단일 시작점 최단 경로 알고리즘이다. BFS에서는 큐를 사용하지만, 다익스트라 알고리즘은 우선순위 큐를 사용한다. 우선순위 큐에는 정점의 번호와 지금까지 찾아낸 해당 정점까지의 최단 거리를 넣는다.  

**각 정점까지의 최단 경로가 갱신될 수 있다.** 예를 들어 정점 `c`까지의 최단 거리가 12인줄 알았다가, 9인 경로를 발견했다고 하자. 이 때 우선순위 큐에는 `(12,c)`를 **그대로 두고,** `(9,c)`를 넣는다. `dist[c]=9`를 설정한 뒤, 나중에 우선순위 큐에서 `(12,c)`가 나오면 `dist[c]<12`이므로 무시하면 된다.  

`STL`의 `priority_queue`를 사용한다면, `pair<int,int>`는 앞의 수를 먼저 비교하므로 `(-최단 경로의 길이, 정점 번호)`꼴로 저장한다. `prioirty_queue`는 prority가 큰 수가 top이지만, 나는 최단 경로의 길이가 짧은 것을 top으로 생각하고 싶기 때문에 **최단 경로의 길이에 -1을 곱해서 넣는다.**

`priority_queue`에 `(0,시작 정점)`을 넣으며 시작한다. 다익스트라 알고리즘에서 선택한 간선을 모으면 BFS 스패닝트리와 같은 트리 형태가 된다. 이 트리의 루트에서 각 정점까지로 가는 경로가 원래 그래프에서의 최단 경로이다.

### 정당성 증명  

귀류법을 위해 다익스트라 알고리즘이 최단 거리를 제대로 계산하지 못하는 정점 u가 있다고 가정하자. 이런 정점이 두 개 이상이면 그중 첫 번째로 방문하는 정점을 선택한다.  

시작점에 대해서는 항상 최단 경로가 0임을 알기 때문에, u는 시작점이 아니다. 그러면 다익스트라 알고리즘에서 u를 방문하는 순간, u 이전에 방문한 정점들과 아직 방문하지 않은 정점들로 나눌 수 있다. 이때 u에 대한 최단 거리를 잘못 계산했다는 것은 다익스트라 알고리즘에서 만든 스패닝 트리에서의 경로보다 더 짧은 경로가 존재한다는 것이다.  

시작점으로부터 정점 u까지의 최단 경로를 반대로 따라가다보면, 이미 방문한 정점 p가 나온다. 정점 p와 연결되었고 위 경로에 있지만 아직 방문하지 않은 정점을 정점 q라고 하자. 정점 q까지의 최단거리는 `dist[p]+w(p,q)`이다. 그런데 정점 p가 이미 방문된 상태이므로 정점 q는 이미 우선순위 큐에 들어가 있다. 하지만 정점 u가 정점 q보다 먼저 우선순위 큐에서 꺼내졌으므로 `dist[u]<=dist[q]`이다. 하지만 이는 정점 u로 가는 최단 경로가 정점 q를 지난다는 사실에 모순이다.  

이와 같이 스패닝 트리 위의 경로보다 짧은 경로는 존재할 수 없으므로, 다익스트라 알고리즘이 찾아내는 경로가 최단 경로이다. 하지만 다익스트라 알고리즘은 **음수 간선이 없다고 가정한다.** 

### 다익스트라 알고리즘의 시간 복잡도

- 각 정점마다 인접한 간선들을 모두 검사하는 작업
  - 각 정점은 한 번씩만 방문되고, 따라서 모든 간선은 한 번씩 검사됨
  - `O(|E|)`
- 우선순위 큐에 원소를 넣고 삭제하는 작업
  - BFS에서는 모든 정점이 큐에 한 번씩만 들어가기 때문에 큐의 최대 크기는 `O(|V|)`
  - 하지만 `dist[]`가 갱신될 때마다 원소를 우선순위 큐에 넣는다. 간선마다 최대 한 번 큐에 원소를 추가하므로, 큐의 최대 크기는 `O(|E|)`
  - 우선순위 큐에 원소를 추가하거나 삭제하는데는 `O(lg|E|)`
  - 따라서 전체 시간복잗보는 `O(|E|lg|E|)`
- 두 작업을 합치면 `O(|E|+|E|lg|E|)=O(|E|lg|E|)`인데, 대개의 경우 `|E|`는 `|V|^2`보다 작으므로, `O(|E|lg|E|)=O(|E|lg|V|*2)=O(|E|lg|V|)`이다.

### 최단 경로 찾기

다익스트라 알고리즘을 통해 얻은 스패닝 트리를 거슬러 올라가는 경로가 최단 경로이다.

### O(|V|lg|V|)에 다익스트라 구현하기  

중복 원소를 우선순위 큐에 넣지 않으면 `O(|V|lg|V|)`로 짤 수 있지만, 이러려면 피보나치 힙이나 이진 검색 트리를 이용해 우선순위 큐를 작성해야 한다. 이는 시간 복잡도는 줄여주지만 복잡하며, 더 느릴 수도 있다.

### 우선순위 큐를 사용하지 않는 다익스트라 알고리즘의 구현  

정점의 수가 적거나 간선의 수가 매우 많은 경우에는 우선순위 큐를 사용하지 않을 때 더 빠를 수 있다. 우선순위 큐 대신 반복문을 통해 매번 방문하지 않은 정점 중 `dist[]` 값이 가장 작은 정점을 찾는다. 이 경우 시간복잡도는 `O(|V|^2+|E|)`이다.  


## 벨만-포드(Bellman-Ford)의 최단 경로 알고리즘  

다익스트라 알고리즘은 음수 간선이 있으면 정당성이 보장되지 않는다. 벨만-포드의 최단 경로 알고리즘은 다익스트라 알고리즘처럼 단일 시작점 최단 경로 알고리즘이지만, 음수 간선이 있는 그래프에 대해서 최단 경로를 찾을 수 있다. 또한 그래프에 음수 사이클이 있어서 최단 거리가 제대로 정의되지 않을 경우 이것도 알려준다.  

벨만-포드 알고리즘은 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤 예측 값과 실제 거리 사이의 오차를 줄여나가는 방식이다. 너비 우선 탐색을 통해 한 번에 한 정점씩 최단 거리를 확정하는 다익스트라 알고리즘과 아주 다르다. 벨만-포드 알고리즘은 수행 과정에서 각 정점까지의 최단 거리의 상한을 `upper[]`에 유지하며, 종료 시에는 모든 정점으로 가는 최단 거리가 `upper[]`에 담기게 된다.

### 벨만-포드의 동작 과정

처음에는 아는 것이 시작점부터 시작점까지의 거리가 0인 것 뿐이다. `upper[s]=0`으로 초기화한 후, 나머지 원소는 모두 아주 큰 수 `INF`로 초기화한다. 그리고 `dist[v]<=dist[u]+w(u,v)`가 항상 성립함을 이용한다. 만약 `upper[u]+w(u,v)<upper[v]`라면, `upper[v]`를 `upper[u]+w(u,v)`로 줄일 수 있는데, 이 과정을 완화(relax)한다고 한다. 벨만-포드 알고리즘은 모든 간선에 대해 완화를 반복적으로 실행하며, 완화가 성공할 때마다 `upper`는 줄어들어 실제 최단 경로의 길이와 가까워진다.

### 종료 조건과 정당성의 증명  

모든 간선에 대해 완화를 x번 할 때마다 x개 이하의 정점의 최단 거리를 확정하게 된다. 따라서 모든 간선이 전부 완화가 실패할 때까지 반복하면 모든 최단 경로를 찾을 수 있다.  

음수 사이클이 없는 그래프에서 최단 경로가 한 정점을 두 번 지나지 않으므로, 최단 경로는 최대 `|V|-1`개의 간선을 가진다. 따라서 모든 간선에 대한 완화 과정은 `|V|-1`번이면 충분하다.

벨만-포드 알고리즘은 음수 간선이 없다고 가정하지 않으므로, 음수 간선이 있는 경우에도 최단 거리를 올바르게 계산할 수 있다.

### 음수 사이클의 판정  

벨만-포드 알고리즘은 음수 사이클의 존재 여부를 판정할 수 있다. `|V|`번 완화를 시도해서, `|V|`번째 반복에서도 완화가 한 번이라도 성공하면 음수 사이클이 존재하는 것이다. `|V|-1`번 완화를 진행한 후, 음수 사이클에 속하는 정점들 중 하나의 간선에서는 다시 완화가 가능하기 때문이다. 

### 구현  

- `upper[]`에서 시작점 s만 `upper[s]=0`, 나머지 점들은 `upper[v]=INF`
- `|V|`번 완화 시도
  - `upper[there]>upper[here]+w(here,there)`이면 완화
- `|V|`번째에도 한 번 이상 완화되면 빈 벡터를 리턴
- 시간복잡도는 `O(|V||E|)`이다.

### 실제 경로 계산하기  

벨만-포드 알고리즘을 수행하며 각 정점을 마지막으로 완화시킨 간선들을 모으면 스패닝 트리가 된다. 각 정점을 마지막으로 완화시킨 간선은 항상 최단 경로 위에 있기 때문이다.

### 빠지기 쉬운 함정
벨만-포드 알고리즘 종료 후 `upper[v]<INF`면 시작점에서 v로 가는 경로가 존재한다고 잘못 생각할 수 있다. 하지만, s와 연결되지 않은 두 점 x,y 사이에 음수 사이클이 존재하면 `upper[x]`, `upper[y]`가 `INF`보다 작아진다. 따라서 시작점에서 v로 가는 경로가 존재하는지 확인하려면 적당히 큰 값 M에 대해 `upper[v]<INF-M`인지 확인해야 한다.  

**다익스트라 알고리즘에서는 가중치가 가장 작은 간선부터 탐색하기 위해 우선순위 큐를 사용했는데, 벨만-포드 알고리즘은 우선순위 큐를 사용하지 않아도 된다.**  

## 플로이드의 모든 쌍 최단 거리 알고리즘

모든 쌍 간의 최단 거리를 구하고 싶을 때는 플로이드(Floyd)의 모든 쌍 최단 거리 알고리즘을 이용하면 좋다.  

### 정점의 경유점들

두 정점 `u, v`를 잇는 경로가 있을 때, 이 경로에서 시작점 `u`와 끝점 `v`를 제외한 다른 정점들을 **경유점**이라고 한다. 

### 플로이드 알고리즘의 프로토타입  

`S_k={0,1,...,k}`라고 두고, `C_k=D_(S_k)`일때 `C_k(u,v)=0번 정점부터 k번 정점까지만을 경유점으로 썼을 때 u에서 v까지 가는 최단 거리`라고 하자. k번째 정점을 사용할지 않을지에 따라 다음과 같이 `C_k(u,v)`를 구할 수 있다. **`C_k(u,v)=min( C_k-1(u,k)+C_k-1(k,v) , C_k-1(u,v) )`**  

플로이드 알고리즘에서는 인접 리스트가 아닌 **인접 행렬을 이용하여 정점 사이의 간선을 표시하는 것이 편하다.** 이 때, 간선을 갖지 않은 두 정점은 `adj[x][y]`의 값을 충분히 큰 값을 넣어두면, 간선이 있는 경우와 없는 경우를 구분할 필요 없이 마지막에 구한 최단 거리가 일정 값보다 크면 경로가 없는 것으로 판단할 수 있다.  

### 메모리 사용량 줄이기
단순하게 플로이드 알고리즘을 적용하면, `C[V][V][V]`의 `C[k][u][v]`안에 `C_k(u,v)`를 넣을 수 있다. 9단원에서 배운 슬라이딩 윈도우 기법을 이용하여 k%2를 첫 인덱스로 사용하면 `C`의 크기를 `C[2][V][V]`까지 줄일 수 있지만, 플로이드 알고리즘은 한 단계 더 나아간다.  

C_k-1(u,k) = 시작점부터 k-1번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 거리
C_k(u,k) = 시작점부터 k번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 거리

시작점이나 끝점이 k번 정점일 때, 경유점에 k번 정점이 추가되는 것은 아무 의미가 없으므로, `C_k-1(u,k)=C_k(u,k)`이다. 따라서 C의 크기는 `C[V][V]`면 된다.

### 구현
우선 인접 행렬 `adj[V][V]`에 `adj[u][v]`는 u와 v를 잇는 간선의 가중치를 (이어지지 않으면 충분히 큰 값을) 넣고, `adj[i][i]`는 모두 0을 넣는다. 그 후, k를 늘려가며 `adj[i][j]=min(adj[i][j], adj[i][k]+adj[k][j]])`를 실행한다. 시간 복잡도는 `O(|V|^3)`, 공간 복잡도는 `O(|V|^2)`이다.

### 플로이드 알고리즘의 최적화
시간 제한에 아슬아슬하게 걸리는 경우, 두 번째 i에 대한 for문에서 i에서 k로 가는 경로가 없으면 건너뜀으로써 최적화해줄 수 있다.

### 실제 경로 계산하기
각 정점의 쌍 u,v에 대하여 마지막으로 `adj[u][v]`를 갱신했을 때 사용한 k의 값을 따로 저장해두면 된다. u에서 k로 가는 경로와 k에서 v로 가는 경로를 합치면 u에서 v로 가는 최단 경로이다.

### 도달 가능성 확인하기
C_k(u,v)의 정의를 **0번부터 k번 정점까지 썼을 때, u에서 v로 가는 경로가 있는지 여부**를 나타내도록 바꾸면, `C_k(u,v)=C_k-1(u,v)||(C_k-1(u,k)&&C_k-1(k,v))`이다. 시간 복잡도 면에서는 BFS보다 나을 것도 없지만, 모든 정점 사이의 도달 가능성을 따질 때는 구현이 간단해서 자주 쓰인다.
