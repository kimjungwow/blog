---
title: "Algospot :: Greedy Method"
date: 2020-03-09 18:01:00 +0900
categories: 알고리즘_공부
tags: Algospot Greedy_Method
---

# Greedy Method (탐욕법) : AOJ 10단원  

## 탐욕법이란?

완전 탐색이나 DP와 달리, **탐욕법에서는 지금 당장 가장 좋은 방법만을 선택한다.** 탐욕법을 사용해도 항상 초적해를 구할 수 있는 문제를 만나면 DP보다 훨씬 빠르기 떄문에 유용하다. 혹은 시간이나 공간적 제약으로 최적해를 찾기 어렵다면, 적당히 괜찮은 답(근사해)를 찾는 데 사용된다. 탐욕법은 간단하지만 한 문제를 탐욕적으로 해결하는 방법이 한 가지가 아닌 경우가 많다. 따라서 탐욕적 알고리즘 연습 문제를 풀 때는 알고리즘의 정당성을 증명하는 과정을 빼먹지 않고 연습하는 것이 좋다.  

## 예제: 회의실 예약

탐욕법이 유용하게 사용되는 예로 활동 선택 문제(activity selection problem)이 있다. 회의실 하나를 두고 n개의 팀이 각각 회의하고 싶은 시간을 제출했을 때, 최대 몇 개의 팀이 회의를 할 수 있을까?

### 무식하게 풀 수 있을까?
서로 겹치지 않는 회의들의 집합 중 최적해는 가장 크기가 큰 부분 집합이다. `2^n`개의 부분 집합을 하나씩 따져보기에는 시간이 너무 오래 걸린다.

### 탐욕적 알고리즘의 구상
이런 문제를 **탐욕적으로** 해결하는 방법을 여러가지가 있을 수 있다. 가장 짧은 회의 시간을 먼저 택하는 것을 예로 들면, 3개의 회의 시간 중 가장 짧은 회의 시간이 나머지 2개의 회의 시간과 겹치면 가장 짧은 회의 시간을 택하는 것은 옳지 않다. 이 문제를 해결하는 탐욕적인 방법은 길이와 상관없이 가장 먼저 끝나는 회의부터 선택하는 것이다. 가장 먼저 끝나는 회의를 선택하고, 이 회의와 겹치는 것들을 모두 지운 뒤 다시 이 중에서 가장 먼저 끝나는 회의를 선택하기를 반복하는 것이다.
1. 목록 S에 남은 회의 중 가장 일찍 끝나는 회의 S_min을 선택한다.
1. S_min과 겹치는 회의를 S에서 지운다.
1. S가 텅 빌 때까지 반복한다.

### 정당성의 증명: 탐욕적 선택 속성
1. **답의 모든 부분을 고려하지 않고 탐욕적으로 선택해도 최적해를 구할 수 있다** = **탐욕적 선택 속성(greedy choice property)** 증명
  - 어떤 알고리즘에 이 속성이 성립할 경우, 각 단계에서 내리는 탐욕적 선택은 항상 최적해로 가는 길 중 하나이다.
  - 이 문제에서는, 가장 종료시간이 빠른 회의(S_min)을 포함하는 최적해가 반드시 존재한다.
    - 증명 : S의 최적해 중 S_min을 포함하지 않는 최적해가 있다고 할 때, 이 목록에서 첫 번째로 개최되는 회의는 S_min보다 늦게 끝난다. 따라서 첫 번째로 개최되는 회의를 지우고 S_min을 넣어도 두 번째 회의와 겹치지 않으며, 새로 만든 목록도 최적해 중 하나이다. 따라서 S_min을 포함하는 최적해는 존재한다.
2. **항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있다** = **최적 부분 구조(optimal substructure)** 증명
  - 첫 번째 선택을 하고 나서 남는 부분 문제는 최적이 아닌 방법으로 풀어야 하는 경우는 성립하지 않지만, 대개 매우 자명함
  - 이 문제에서는, 첫 번째 회의를 잘 선택하고 겹치는 회의를 모두 걸러냈다면, 남은 회의 중에서 당연히 최대한 많은 회의를 선택해야 함

### 구현

모든 회의의 목록을 저장해두고, 한 회의를 선택할 때마다 겹치는 회의를 모두 제거하면 이해는 쉽지만 구현하기 번거롭다. 그래서 처음에 모든 회의를 종료 시간의 오름차순으로 정렬 후, 가장 앞의 회의를 고른다. 그 후 첫 번째 회의와 겹치지 않는 회의를 찾다가, 발견하면 나머지를 보지 않고 선택해도 된다. **이와 같이 특정 조건으로 객체들을 정렬해두면 탐욕법의 구현이 쉬워지는 경우가 많다.**

### 탐욕법과 동적 계획법

탐욕버으로 최적해를 찾을 수 있다는 말은 지금 한 단계만 고려해도 답을 찾을 수 있다는 뜻이다. 모든 단계를 고려하는 동적 계획법이 답이 틀릴 리가 없다. 하지만 동적 계획법에 필요한 메모리나 시간이 과도하게 큰 경우가 많다.

### 예제 : [출전 순서 정하기](https://kimjungwow.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/MATCHORDER/)

### 탐욕적 알고리즘 레시피
1. 문제의 답을 만드는 과정을 여러 조각으로 나눈다.
1. 각 조각마다 어떤 우선순위로 선택을 내려야 할지 결정한다. 이에 대한 직관을 얻기 위해서는 예제 입력이나 그 외의 작은 입력을 몇 개 손으로 풀어보는 것이 효율적이다.
1. 어떤 방식이 동작할 것 같으면 두 가지의 속성을 증명해본다.
    1. 탐욕적 선택 속성 : 항상 각 단계에서 내가 선택한 답을 포함하는 최적해가 존재함을 보이면 된다. 이 증명은 대개 우리가 선택한 답과 다른 최적해가 존재함을 가정하고, 이것을 조작해서 우리가 선택한 답을 포함하는 최적해로 바꿀 수 있음을 보이는 형태로 이루어진다.
    1. 최적 부분 구조 : 각 단계에서 항상 최적의 선택만을 했을 때 전체 최적해를 구할 수 있는지 여부를 증명한다. 대개의 경우 자명하다.