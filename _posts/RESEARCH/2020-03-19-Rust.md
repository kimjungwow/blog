---
title: "Study :: Rust"
date: 2020-03-19 16:01:00 -0400
categories: Study
tags: Study Rust
---
# [Rust](https://doc.rust-lang.org/book/) 읽고 몰랐던 내용 정리

- 함수 선언 순서가 상관 없음 -> 컴파일 시 전체 코드를 먼저 훑고 어떤 함수들이 있는지 확인하는 듯
- 컴파일 시 unsigned 타입에서 오버플로우 발생하면 경고 띄움. 하지만 런타임에는 나머지 연산을 취함
- tuple/array는 고정된 크기 가짐. 가변 크기는 vector
- array의 잘못된 인덱스 접근 시 런타임 에러 발생
- statement / expression
  - statement : 리턴 안 함. 세미 콜론으로 끝남. `let`은 statement이기 때문에, `let x = (let y = 6);`도 안 됨.
    - `but statements don’t evaluate to a value, which is expressed by (), an empty tuple.`
  - expression : 리턴 함. 세미 콜론 x. `6`도 expression.
- compile time에 변수의 타입을 알아야 함.
- Heap/Stack
  - S는 원소 개수 고정/ 마지막 원소만 접근 가능 | H는 원소 개수 가변 / 원하는 원소 접근 가능
  - S는 집어넣으면 끝이므로 빠름 | H는 빈 공간 찾아서 allocate하고, 포인터 위치 기억하고, 메모리가 꽉 차지 않기 위해 안 쓰는 데이터는 지워야 하므로 오래 걸림
  - 함수 호출시, 함수에 전해지는 value들과 함수 내의 변수들은 스택에 저장된다. 함수가 종료되면 모두 스택에서 pop된다
- Ownership Rules
  - Rust에서 각 value는 그것의 *owner*라 불리는 variable을 가짐
  - 한 번에 하나의 owner만 존재 가능
  - owner가 scope를 벗어나면, value는 dropped
- 예 : String
  - `let s = "hello";`로 하드코딩하면 길이를 더 못늘림 (immutable)
  - `let s = String::from("hello")`하면 `s.push_str(", world!");`로 늘릴 수 있으며, heap에 저장됨. 런타임에 용량이 정해지며, 런타임에 OS로부터 메모리를 요구하고(`String::from`이 함) 사용이 끝나면 반납함.
  - allocate마다 free를 직접 해주려면 어렵기 때문에, Rust에서는 변수의 scope를 벗어나면 자동적으로 `drop()`이 호출되어 메모리를 반납한다.
- Ways Variables and Data Interact : Move
  - ![move1](https://doc.rust-lang.org/book/img/trpl04-02.svg)
  - `let s1 = String::from("hello"); let s2 = s1;` 실행 시 위 그림과 같이 된다면, s1과 s2의 scope를 벗어날 때 각각 `drop()`을 호출하여 같은 메모리를 두 번 free 해 오류가 생긴다. 그렇다고 heap의 메모리를 복사하면 너무 오래 걸린다. 따라서 아래와 같이 s1은 유효하지 않다고 만든다. 이를 `s1이 s2로 moved 되었다.`라고 한다.
  - ![move2](https://doc.rust-lang.org/book/img/trpl04-04.svg)
- Ways Variables and Data Interact : Clone
  - heap의 메모리까지 복사하고 싶으면 `let s2=s1.clone();`을 하면 된다. 이를 clone이라고 한다.
- Stack-Only Data : Copy
  - integer처럼 컴파일 타임에 그 크기가 알려져있는 타입은 **stack에** 저장된다. 따라서 actual value를 복사하는 것도 빨리 된다. 따라서 `let x = 5; let y = x;`를 해도 x가 유효해도 문제가 없다.
  - `Drop` trait이 있는 타입에 `Copy` trait 사용 시 컴파일 에러 발생
- Ownership and Functions
  - 함수에 value를 전달 시, string이면 함수가 끝날 때 `drop()`이 호출되서 함수 이후에 다시 사용하려하면 컴파일 에러가 발생한다.
  - 예 : `let s = String::from("hello"); takes_ownership(s);` 실행 시 `takes_ownership(s)`이후에는 s에 `drop()`이 호출되어 사용할 수 없다.
  - 하지만 integer 같은 static type은 `copy()`를 사용해서, 그 변수를 사용한 함수가 끝나도 문제 없이 변수를 사용할 수 있다.
- Reference and Borrowing
  - 함수에 value를 전달시 &를 붙이면 reference를 전달하기 떄문에, ownership이 넘어가지 않는다. 따라서 함수가 종료되어도 변화가 없다.
  - reference를 function parameter로 가지는 것을 *borrowing*이라고 한다. reference로 받은 variable의 value를 바꿀 수 없다. (reference도 기본적으로 immutable) 
- Mutable Reference
  - `change(&mut s)`, `fn change(some_string: &mut String)`과 같이 사용하여 mutable reference를 만들 수 있다. 하지만 Rust에서는 한 scope에는 하나의 mutable reference만 있어야 한다.
  - 하나의 mutable referecne만 존재 가능하도록 하여 *data race*를 막는다. *data race*란 동시에 아래의 세 상황일 때 발생한다.
    - 두 개 이상의 포인터가 동시에 같은 데이터에 접근한다.
    - 한 개 이상의 포인터가 데이터를 수정한다.
    - 데이터 접근을 synchronize 하는 매커니즘이 없다.
  - mutable reference 뒤에서 immutable reference가 쓰이면 에러가 발생한다.
  - 하지만 mutable reference 앞에만 immutable reference가 있으면 문제가 없다. reference의 scope는 선언될 때부터 마지막으로 쓰일 때까지이기 때문이다.
- Dangling References
  - 이미 free된 메모리를 가리키는 포인터를 dangling pointer라하는데, Rust는 이를 컴파일 에러로 막는다.
  - 예를 들어, 함수 안이 scope인 변수의 reference를 리턴하면 컴파일 에러가 발생한다. 이 경우 변수 자체를 리턴하면 ownership이 함수 밖으로 넘어가기 때문에 문제가 없다.
- The Rules of References
  - At any given time, you can have either one mutable reference or any number of immutable references.
  - References must always be valid.
- String Slices
  - Slice는 첫 원소로의 reference와 길이를 저장한다.
  - `[starting_index..ending_index]` 꼴로 String의 일부를 reference 가능. `starting_index`가 0이면 생략 가능. `ending_index`가 마지막 byte면 생략 가능. `[..]`면 전체 String.
  - Binary에 저장된 String Literals(하드코딩된 스트링)도 Slices이다. Slices니까 reference이고, immutable이다.
- enum에는 한 번에 한 값이 들어간다.
  - 각 enum마다 다른 개수, 다른 타입의 associated data를 소유할 수 있다.
  - `impl`로 enum, struct의 method를 만들 수 있다.
- Option : enum 중 하나. Some(T)와 None으로 구성됨
  - 자동으로 precluded
  - None은 타입을 명시해줘야 함.
  - `Option<T>`와 `T`는 다르기 때문에, 컴파일러는 `Option<T>`가 무조건 valid라고 생각하지 않는다. 그냥 `T`가 오면 확인 없이 valid라고 생각해도 된다.-> null대신 Option을 쓰는 이유. null을 사용하면 실제로는 null인데 null이 아니라고 생각해서 에러가 생길 수 있다.
  - `unwrap`을 이용해 내부의 값 얻음
- match는 exhaustive : 가능한 모든 값들을 다루어야 함. `_`는 placeholder로써, else 대체 (아무 값이나와 다 match). `()`는 unit value : nothing will hapen
- `if let Some(3) = some_u8_value`로 특정 패턴과만 expression을 비교해볼 수 있찌만, `if let`은 exhaustive X
- crate : a binary or library
- packages : a set of functionality를 제공하는 one or more crates. binary crates는 제한 없이 포함할 수 있지만, library crates는 최대 1개.
  - 어떻게 crates를 빌드할 수 있는지 알려주는 `Cargo.toml`를 포함
    - `src/main.rs`는 crate root of a binary crate
    - package directory가 `src/lib.rs`를 포함하면, 같은 이름의 library crate를 package로써 포함하며, `src/lib.rs`는 그것의 crate root이다. -> 무슨 소리인지 모르겠다
    - Cargo는 library/binary를 빌드하기 위해 crate root files를 rustc에 전달한다.
    - 패키지는 `src/bin` 디렉토리에 파일들을 놓음으로써 여러개의 binary crates를 가질 수 있다.
    - crate의 functionality를 그것의 scope안에 두어서 특정 functionality가 어느 crate에 정의되어있는지 알기 좋다. 예를 들어, `rand` crate에는 `Rng`라는 trait가 있는데, 우리가 `Rng`라는 `struct`를 만들고 `Rng`를 사용하면 이는 `struct Rng`를 의미한다. `rand` crate의 `Rng` trait를 이용하려면 `rand::Rng`를 사용하면 된다.

- Modules : 한 crate 안의 코드를 여러 그룹으로 조직하여 읽기 좋고 재사용하기 좋게 해줌
  - 절대경로 : 같은 crate면 crate로 시작 가능
  - Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules
  - Rust에서는 item의 default : private. 아니면 `pub` 사용해야 함. 이 때 `pub`는 오직 (한 단계) ancestor에게만 영향을 끼치므로, 두 단계 아래면 `pub` 두 번 써야함.
  - `super`를 사용하면 `..`처럼 parent module 나타낼 수 있음
  - `struct`에는 앞에 `pub`를 써도 안의 field들은 pub이 아니다. 따라서 각각 `pub`을 써줘야 한다. 하지만 `enum`은 앞에만 `pub`을 써도 그 안의 variant들도 사용 가능하다.
- `use`는 filesystem에서 symbolic link를 만드는 것과 비슷하다. `use`는 절대/상대 경로 모두 가능하다. `use`로 function까지 scope로 가져올 수도 있겠지만, parent module까지만 가져와야 그 function이 not locally defined임이 명확해진다. 하지만 structs, enums나 다른 items를 가져올 때는 full path를 적는 것이 관용적이다 (같은 이름의 item 두 개 가져올 때는 제외).
- 같은 이름의 item 두 개 가져올 때는 하나를 `as` keyword를 이용해 다른 이름으로 가져올 수 있다.
- `pub use`를 통해 `use`로 가져온 코드를 사용하는 코드를 외부에서 사용할 때도 잘 실행되게 한다.
- 외부 package 사용하려면 `Cargo.toml`에 적은 후 `use` 사용. 하지만 `std`는 `Cargo.toml`에 안 적어도 됨 (use는 필수)
- 같은 package/module에서 여러 item 가져올 때는 `use std::{cmp::Ordering, io}`나 `use std::io::{self,Write};`면 됨. `*` (Glob operator)도 사용 가능.

- [modules를 다른 파일에 분리하기](https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html)
  - `src/lib.rs`나 `src/main.rs`에 `mod front_of_house; pub use crate::front_of_house::hosting;`라 해놓고, `src/front_of_house.rs`에 `hosting`과 `add_to_waitlist()`해놔도 잘 작동한다. 한층 더 `front_of_house`라는 폴더를 `src`안에 만들고, 그 안에 `hosting.rs`를 만들어도 된다.

- Vector
  - `let v: Vec<i32> = Vec::new();` 혹은 `let v = vec![1, 2, 3];`
  - `[]`, `&` 사용 : Reference | .get() : Option<T>
  - 잘못된 index 사용시 : Refernce는 panicking, option은 None 리턴
  - 맨 앞의 reference를 immutable로 선언하고, mut 변수를 이용해 벡터의 값을 바꾼뒤 다시 immutable reference를 사용하면 안 됨. 벡터에 새로운 원소를 추가할 때 공간이 없으면 기존에 가리키던 ref는 deallocated address를 가리키게 될 수도 있기 때문이다.
  - 벡터에 여러 타입을 넣고 싶으면, 여러 타입을 담을 수 있는 타입인 `enum` 이용. `enum`은 `match`로 모든 경우를 커버하는지 컴파일 타임에 체크됨.

- String
  - `let s = format!("{}-{}-{}", s1, s2, s3);` 꼴로 스트링 합칠 수 있음
  - Rust에서는 index로 한 글자마다 접근할 수 없음. 각 글자가 2바이트 이상인 경우도 있기 때문. 이렇게 글자마다 바이트 개수가 경우 특정 인덱스에 접근하는 것이 O(1)이 아님
  - String은 Bytes/Scalar Values / Grapheme Clusters로 해석됨.
  - Slicing으로 `[..]`사용하면 지정한 **바이트**로 자름. 2바이트 글자들에 대하여 `[0..4]`는 앞의 두 글자. char boundary가 아닌 인덱스 선택시 panic
  - `.chars()`와 `.bytes()`를 사용해 for loop에서 iterating 가능

- Hashmap
  - 역시 같은 type들만 포함해야 함. vector of tuples에 대하여 `.collect()`를 사용해서도 만들 수 있음
  - `i32`처럼 `Copy` trait을 가진 애는 실제 값이 hash map안으로 복사됨
  - String같은 owned value들은 ownership이 hash map으로 넘어가서, hash map에 넣은 이후에는 기존의 변수는 ownership이 없음
  - `.entry()`와 `.or_insert()`를 사용해 key에 해당하는 value가 없을 떄만 삽입 가능. 이 때 `or_insert` method는 mutable reference를 리턴한다.

- Error Handling
  - recoverable error : result / unrecoverable : panic
  - Panic : clean stack(unwind) / 바로 안 비움 (abort)
  - `Err(error)`의 `error.kind()`를 `match`하여 에러의 종류에 따라 다르게 대처 가능
  
**11.3 다시**

- I/O project
  - `env::args().collect()`로 주어진 arguments를 `Vec<string>`으로 만듦
  - `collect()`로 collection 만들 때, type을 명확히 해주어(annotate)야함

- Generic
  - monomorphization : 컴파일 타임에 Generic으로 정의된 것을 적절한 타입으로 정하므로, 런타임에 속도가 느려지지는 않는다.

- trait
  - 각 trait은 method들을 가지며, trait을 갖는 타입들은 trait 내부의 메소드를 각각의 방식으로 구현해 가지고 있어야 함
  - orphan rule : external traits on external types 정의 못 함
  - `impl trait for type {}`하면 default trait 이용. `{}`안에 구현하면 override a default implementation
  - method 안에서 같은 method의 default implementation을 호출하는 것은 불가능
  - 함수의 파라미터로 특정 타입 대신 `item: impl Summary`와 같이 특정 trait을 가지는 타입들을 파라미터로 받도록 할 수 있음
  - Trait Bounds : `pub fn notify(item1: impl Summary, item2: impl Summary)`는 두 파라미터가 Summary trait을 가지되 달라도 상관 없지만, `pub fn notify<T: Summary>(item1: T, item2: T)`는 두 파라미터의 타입이 같아야 함.
  - `pub fn notify<T: Summary + Display>(item: T)`이면 `Summary`와 `Display` 두 trait 모두 필요로 하는 trait bound
  - `where` clauses로 trait bounds를 깔끔히 표현 가능
  - `impl Trait`을 리턴 타입으로 정하면, Trait을 가지는 특정 타입이 리턴되지만 컴파일러는 정확히 어떤 타입인지는 모름. 하나의 타입만을 리턴해야 함.
  - **blanket implementation** trait bound를 만족하는 경우에만 trait을 generic에 구현, 예 : `impl<T: Display> ToString for T` 
- lifetime
  - scope for which reference is valid
  - generic lifetime parameter : `'a`
  - lifetime annotation : `&'a`
  - 두 파라미터, return value에 같은 lifetime annotation두면, 리턴값은 적어도 두 파라미터 중 더 짧은 라이프타임만큼 유지되도록 함(그맇지않으면 컴파일러가 거부) 
  - 라이프타임을 바꾸지는 않고, 그에 맞지않은 것을 거부하기 위함
