---
title: "Study :: Rust"
date: 2020-03-19 16:01:00 -0400
categories: Study
tags: Study Rust
---
# [Rust](https://doc.rust-lang.org/book/) 읽고 몰랐던 내용 정리

- 함수 선언 순서가 상관 없음 -> 컴파일 시 전체 코드를 먼저 훑고 어떤 함수들이 있는지 확인하는 듯
- 컴파일 시 unsigned 타입에서 오버플로우 발생하면 경고 띄움. 하지만 런타임에는 나머지 연산을 취함
- tuple/array는 고정된 크기 가짐. 가변 크기는 vector
- array의 잘못된 인덱스 접근 시 런타임 에러 발생
- statement / expression
  - statement : 리턴 안 함. 세미 콜론으로 끝남. `let`은 statement이기 때문에, `let x = (let y = 6);`도 안 됨.
    - `but statements don’t evaluate to a value, which is expressed by (), an empty tuple.`
  - expression : 리턴 함. 세미 콜론 x. `6`도 expression.
- compile time에 변수의 타입을 알아야 함.
- Heap/Stack
  - S는 원소 개수 고정/ 마지막 원소만 접근 가능 | H는 원소 개수 가변 / 원하는 원소 접근 가능
  - S는 집어넣으면 끝이므로 빠름 | H는 빈 공간 찾아서 allocate하고, 포인터 위치 기억하고, 메모리가 꽉 차지 않기 위해 안 쓰는 데이터는 지워야 하므로 오래 걸림
  - 함수 호출시, 함수에 전해지는 value들과 함수 내의 변수들은 스택에 저장된다. 함수가 종료되면 모두 스택에서 pop된다
- Ownership Rules
  - Rust에서 각 value는 그것의 *owner*라 불리는 variable을 가짐
  - 한 번에 하나의 owner만 존재 가능
  - owner가 scope를 벗어나면, value는 dropped
- 예 : String
  - `let s = "hello";`로 하드코딩하면 길이를 더 못늘림 (immutable)
  - `let s = String::from("hello")`하면 `s.push_str(", world!");`로 늘릴 수 있으며, heap에 저장됨. 런타임에 용량이 정해지며, 런타임에 OS로부터 메모리를 요구하고(`String::from`이 함) 사용이 끝나면 반납함.
  - allocate마다 free를 직접 해주려면 어렵기 때문에, Rust에서는 변수의 scope를 벗어나면 자동적으로 `drop()`이 호출되어 메모리를 반납한다.
- Ways Variables and Data Interact : Move
  - ![move1](https://doc.rust-lang.org/book/img/trpl04-02.svg)
  - `let s1 = String::from("hello"); let s2 = s1;` 실행 시 위 그림과 같이 된다면, s1과 s2의 scope를 벗어날 때 각각 `drop()`을 호출하여 같은 메모리를 두 번 free 해 오류가 생긴다. 그렇다고 heap의 메모리를 복사하면 너무 오래 걸린다. 따라서 아래와 같이 s1은 유효하지 않다고 만든다. 이를 `s1이 s2로 moved 되었다.`라고 한다.
  - ![move2](https://doc.rust-lang.org/book/img/trpl04-04.svg)
- Ways Variables and Data Interact : Clone
  - heap의 메모리까지 복사하고 싶으면 `let s2=s1.clone();`을 하면 된다. 이를 clone이라고 한다.
- Stack-Only Data : Copy
  - integer처럼 컴파일 타임에 그 크기가 알려져있는 타입은 **stack에** 저장된다. 따라서 actual value를 복사하는 것도 빨리 된다. 따라서 `let x = 5; let y = x;`를 해도 x가 유효해도 문제가 없다.
  - `Drop` trait이 있는 타입에 `Copy` trait 사용 시 컴파일 에러 발생
- Ownership and Functions
  - 함수에 value를 전달 시, string이면 함수가 끝날 때 `drop()`이 호출되서 함수 이후에 다시 사용하려하면 컴파일 에러가 발생한다.
  - 예 : `let s = String::from("hello"); takes_ownership(s);` 실행 시 `takes_ownership(s)`이후에는 s에 `drop()`이 호출되어 사용할 수 없다.
  - 하지만 integer 같은 static type은 `copy()`를 사용해서, 그 변수를 사용한 함수가 끝나도 문제 없이 변수를 사용할 수 있다.
- Reference and Borrowing
  - 함수에 value를 전달시 &를 붙이면 reference를 전달하기 떄문에, ownership이 넘어가지 않는다. 따라서 함수가 종료되어도 변화가 없다.
  - reference를 function parameter로 가지는 것을 *borrowing*이라고 한다. reference로 받은 variable의 value를 바꿀 수 없다. (reference도 기본적으로 immutable) 
- Mutable Reference
  - `change(&mut s)`, `fn change(some_string: &mut String)`과 같이 사용하여 mutable reference를 만들 수 있다. 하지만 Rust에서는 한 scope에는 하나의 mutable reference만 있어야 한다.
  - 하나의 mutable referecne만 존재 가능하도록 하여 *data race*를 막는다. *data race*란 동시에 아래의 세 상황일 때 발생한다.
    - 두 개 이상의 포인터가 동시에 같은 데이터에 접근한다.
    - 한 개 이상의 포인터가 데이터를 수정한다.
    - 데이터 접근을 synchronize 하는 매커니즘이 없다.
  - mutable reference 뒤에서 immutable reference가 쓰이면 에러가 발생한다.
  - 하지만 mutable reference 앞에만 immutable reference가 있으면 문제가 없다. reference의 scope는 선언될 때부터 마지막으로 쓰일 때까지이기 때문이다.
- Dangling References
  - 이미 free된 메모리를 가리키는 포인터를 dangling pointer라하는데, Rust는 이를 컴파일 에러로 막는다.
  - 예를 들어, 함수 안이 scope인 변수의 reference를 리턴하면 컴파일 에러가 발생한다. 이 경우 변수 자체를 리턴하면 ownership이 함수 밖으로 넘어가기 때문에 문제가 없다.
- The Rules of References
  - At any given time, you can have either one mutable reference or any number of immutable references.
  - References must always be valid.
- String Slices
  - Slice는 첫 원소로의 reference와 길이를 저장한다.
  - `[starting_index..ending_index]` 꼴로 String의 일부를 reference 가능. `starting_index`가 0이면 생략 가능. `ending_index`가 마지막 byte면 생략 가능. `[..]`면 전체 String.
  - Binary에 저장된 String Literals(하드코딩된 스트링)도 Slices이다. Slices니까 reference이고, immutable이다.
- enum에는 한 번에 한 값이 들어간다.
  - 각 enum마다 다른 개수, 다른 타입의 associated data를 소유할 수 있다.
  - `impl`로 enum, struct의 method를 만들 수 있다.
- Option : enum 중 하나. Some(T)와 None으로 구성됨
  - 자동으로 precluded
  - None은 타입을 명시해줘야 함.
  - `Option<T>`와 `T`는 다르기 때문에, 컴파일러는 `Option<T>`가 무조건 valid라고 생각하지 않는다. 그냥 `T`가 오면 확인 없이 valid라고 생각해도 된다.-> null대신 Option을 쓰는 이유. null을 사용하면 실제로는 null인데 null이 아니라고 생각해서 에러가 생길 수 있다.
  - `unwrap`을 이용해 내부의 값 얻음
- match는 exhaustive : 가능한 모든 값들을 다루어야 함. `_`는 placeholder로써, else 대체 (아무 값이나와 다 match). `()`는 unit value : nothing will hapen
- `if let Some(3) = some_u8_value`로 특정 패턴과만 expression을 비교해볼 수 있찌만, `if let`은 exhaustive X
- crate : a binary or library
- packages : a set of functionality를 제공하는 one or more crates. binary crates는 제한 없이 포함할 수 있지만, library crates는 최대 1개.
  - 어떻게 crates를 빌드할 수 있는지 알려주는 `Cargo.toml`를 포함
    - `src/main.rs`는 crate root of a binary crate
    - package directory가 `src/lib.rs`를 포함하면, 같은 이름의 library crate를 package로써 포함하며, `src/lib.rs`는 그것의 crate root이다. -> 무슨 소리인지 모르겠다
    - Cargo는 library/binary를 빌드하기 위해 crate root files를 rustc에 전달한다.
    - 패키지는 `src/bin` 디렉토리에 파일들을 놓음으로써 여러개의 binary crates를 가질 수 있다.
    - crate의 functionality를 그것의 scope안에 두어서 특정 functionality가 어느 crate에 정의되어있는지 알기 좋다. 예를 들어, `rand` crate에는 `Rng`라는 trait가 있는데, 우리가 `Rng`라는 `struct`를 만들고 `Rng`를 사용하면 이는 `struct Rng`를 의미한다. `rand` crate의 `Rng` trait를 이용하려면 `rand::Rng`를 사용하면 된다.

- Modules : 한 crate 안의 코드를 여러 그룹으로 조직하여 읽기 좋고 재사용하기 좋게 해줌