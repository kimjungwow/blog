---
title: "Research :: xv6: a simple, Unix-like teachinig operating system"
date: 2020-07-11 19:56:00 +0900
categories: Study
tags: Study OS xv6
---
[xv6: a simple, Unix-like teachinig operating system](https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf)를 읽고 기억할 내용을 정리했다.

# Chapter 1 : Operating system interfaces

- **kernel** : 실행 중인 프로그램에 서비스를 제공하는 특별한 프로그램
- **process** : 실행 중인 프로그램. instructions, data, stack으로 구성된 메모리를 가짐.
- 프로세스가 커널의 서비스를 이용하려면 **system call**이라는 procedure call를 발생시킴. 시스템이 kernel space로 실행되다가 다시 user space로 돌아옴

## 1.1 Processes and memory

- xv6의 메모리는 instructions, data, and stack으로 이루어진 user-space memory와 per-process state private to the kernel로 나뉨.
- 쉘은 계속 루프를 돌며 유저가 입력하는 명령어를 읽고, `fork()`, `exec()`, `wait()`을 이용해 명령어를 실행하는 구조
- xv6는 implicit memory allocation. `sbrk()`로 새 메모리의 location 얻음.
- xv6에서 모든 프로세스는 루트로서 동작하기 때문에, 유저 개념은 없음.

## 1.2 I/O and File descriptors

- *file descriptor* : 프로세스가 읽고 쓰는 kernel-managed object를 나타내는 small integer. Files, pipes, and devices를 모두 streams of bytes로 다루게 하는 abstraction.
- `fork()`와 `exec()`을 분리한 이유
  - `fork()`는 parent의 file descriptor table과 memory를 모두 복사하지만, `exec()`은 file table만 복사한다.
  - I/O redirection은 child process는 기존의 0번 file descriptor (stdin)를 닫은 뒤 원하는 object를 open하는 방식으로 진행된다. 즉 `fork()`를 먼저 한 뒤 `exec()`을 하기 전 child process에서 open, pipe, dup 등의 system call을 호출하여 stdin과 stdout을 조작할 수 있는 것이 두 system call을 분리한 이유이다.
- `fork()`시 file descriptor table을 복사하므로, parent와 child는 file offset을 공유한다. 
- `dup()`을 통해 file descriptor을 복사해도 file offset을 공유한다. `2>&1`을 이용해 쉘에게 2번 file descriptor는 1번 file descriptor(stdout)의 duplicate임을 알려줘서 에러메시지도 1번 file descriptor로 출력되도록 하는 것이 그 예이다.

## 1.3 Pipes

- `|`를 이용하여 `echo hello world >/tmp/xyz; wc < /tmp/xyz`를 `echo hello world | wc`로 표현
  - `/tmp/xyz`를 초기화 할 필요가 없고, long stream of data도 전달가능하며, 두 프로그램을 병렬적으로 실행할 수 있음
- Pipe는 한 쪽으로는 write를, 반대쪽에서는 read를 하는 small kernel buffer. 예 : `pipe()`로 프로세스가 pipe에 따른 file descriptor를 갖도록 한다. `fork()`한 뒤, parent에서는 우선 read를 close하고 어느 내용을 write한 뒤 write하는 쪽도 close한다. child는 read, write 모두 close한 뒤 `exec()`하면 stdin에서 읽을 때 pipe에서 읽게 된다. 해당 파이프의 write쪽에 referring된 file descriptor가 모두 close되어야 child가 read하는 것을 멈춘다. 이 방식이 inter-process communication에 적합하다.

## 1.4 File system

- xv6 file system은 uninterpreted byte arrays인 **data files**과 data files, other directories에 대한 named references를 담은 **directories**로 구성
- data file이 아닌 device file을 만드는 `mknod()`
- file descriptor가 가리키는 object의 정보를 보여주는 `Fstat`
- `inode`라 불리는 하나의 파일은 여러 개의 이름 (`link`)를 가질 수 있음.
- `mkdir, ln, rm`처럼 file system operation을 위한 shell command는 user-level이지만, `cd`는 예외이다. chlid process를 fork한 뒤 child process의 current directory를 바꾸는 것은 의미 없기 때문.